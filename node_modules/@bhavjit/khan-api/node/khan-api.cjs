/**
 * Khan API v0.5.2
 * https://khan-api.bhavjit.com
 * Licensed under MIT license
 * Copyright 2023 Bhavjit Chauhan
 */

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Answer: () => Answer,
  BaseMessage: () => BaseMessage,
  Client: () => Client,
  EmailRegex: () => EmailRegex,
  EmailRegexMatch: () => EmailRegexMatch,
  FeedbackFocusKind: () => FeedbackFocusKind,
  FeedbackKeyRegex: () => FeedbackKeyRegex,
  FeedbackKeyRegexMatch: () => FeedbackKeyRegexMatch,
  FeedbackSort: () => FeedbackSort,
  FeedbackType: () => FeedbackType,
  FeedbackTypename: () => FeedbackTypename,
  GoogleIDRegex: () => GoogleIDRegex,
  GoogleIDRegexMatch: () => GoogleIDRegexMatch,
  KaidRegex: () => KaidRegex,
  KaidRegexMatch: () => KaidRegexMatch,
  ListProgramSortOrder: () => ListProgramSortOrder,
  MESSAGE_ENCRYPTED_KEY_LENGTHS: () => MESSAGE_ENCRYPTED_KEY_LENGTHS,
  MESSAGE_KEY_LENGTHS: () => MESSAGE_KEY_LENGTHS,
  Message: () => Message,
  MessageEncryptedKeyRegex: () => MessageEncryptedKeyRegex,
  MessageEncryptedKeyRegexMatch: () => MessageEncryptedKeyRegexMatch,
  MessageType: () => MessageType,
  PROGRAM_ID_LENGTHS: () => PROGRAM_ID_LENGTHS,
  PROGRAM_KEY_LENGTHS: () => PROGRAM_KEY_LENGTHS,
  PROGRAM_URL_LOCALES: () => PROGRAM_URL_LOCALES,
  PROGRAM_URL_PATHS: () => PROGRAM_URL_PATHS,
  PROGRAM_URL_TLDS: () => PROGRAM_URL_TLDS,
  Program: () => Program,
  ProgramEditorType: () => ProgramEditorType,
  ProgramIDRegex: () => ProgramIDRegex,
  ProgramIDRegexMatch: () => ProgramIDRegexMatch,
  ProgramImagePathRegex: () => ProgramImagePathRegex,
  ProgramImagePathRegexMatch: () => ProgramImagePathRegexMatch,
  ProgramKeyRegex: () => ProgramKeyRegex,
  ProgramKeyRegexMatch: () => ProgramKeyRegexMatch,
  ProgramType: () => ProgramType,
  ProgramURLRegex: () => ProgramURLRegex,
  ProgramURLRegexMatch: () => ProgramURLRegexMatch,
  QualarooIDRegex: () => QualarooIDRegex,
  QualarooIDRegexMatch: () => QualarooIDRegexMatch,
  Question: () => Question,
  Reply: () => Reply,
  ServiceErrorCode: () => ServiceErrorCode,
  ServiceErrorName: () => ServiceErrorName,
  TipsAndThanks: () => TipsAndThanks,
  TypeToClass: () => TypeToClass,
  User: () => User,
  UserAccessLevel: () => UserAccessLevel,
  assertDataResponse: () => assertDataResponse,
  avatarNameToSlug: () => avatarNameToSlug,
  avatarNames: () => avatarNames,
  avatarSlugToName: () => avatarSlugToName,
  avatarSlugs: () => avatarSlugs,
  convertAvatarPNGToSVG: () => convertAvatarPNGToSVG,
  convertAvatarSVGToPNG: () => convertAvatarSVGToPNG,
  extractAvatarSlug: () => extractAvatarSlug,
  generateAvatarPNG: () => generateAvatarPNG,
  generateAvatarSVG: () => generateAvatarSVG,
  isAnswerSchema: () => isAnswerSchema,
  isDataResponse: () => isDataResponse,
  isEmail: () => isEmail,
  isEncryptedFeedbackKey: () => isEncryptedFeedbackKey,
  isFeedbackKey: () => isFeedbackKey,
  isGoogleID: () => isGoogleID,
  isInputErrorResponse: () => isInputErrorResponse,
  isKaid: () => isKaid,
  isProgramID: () => isProgramID,
  isProgramKey: () => isProgramKey,
  isProgramURL: () => isProgramURL,
  isQualarooID: () => isQualarooID,
  isQuestionSchema: () => isQuestionSchema,
  isReplySchema: () => isReplySchema,
  isServiceErrorsResponse: () => isServiceErrorsResponse,
  isTipsAndThanksSchema: () => isTipsAndThanksSchema,
  mutations: () => mutations_exports,
  programIDtoKey: () => programIDtoKey,
  programKeyToID: () => programKeyToID,
  queries: () => queries_exports,
  resolveFeedbackKey: () => resolveFeedbackKey,
  resolveKaid: () => resolveKaid,
  resolveProgramID: () => resolveProgramID,
  resolveUsername: () => resolveUsername
});
module.exports = __toCommonJS(src_exports);

// src/queries/index.ts
var queries_exports = {};
__export(queries_exports, {
  AvatarDataForProfile: () => AvatarDataForProfile,
  FeedbackQuery: () => FeedbackQuery,
  GetFeedbackReplies: () => GetFeedbackReplies,
  GetFullUserProfile: () => GetFullUserProfile,
  GetProfileWidgets: () => GetProfileWidgets,
  GetUserByUsernameOrEmail: () => GetUserByUsernameOrEmail,
  GetUserHoverCardProfile: () => GetUserHoverCardProfile,
  ProgramQuery: () => ProgramQuery,
  ProjectsAuthoredByUser: () => ProjectsAuthoredByUser,
  QAExpandKeyInfo: () => QAExpandKeyInfo,
  QaExpandKeyInfo: () => QaExpandKeyInfo,
  avatarDataForProfile: () => avatarDataForProfile,
  feedbackQuery: () => feedbackQuery,
  getFeedbackReplies: () => getFeedbackReplies,
  getFullUserProfile: () => getFullUserProfile,
  getProfileWidgets: () => getProfileWidgets,
  getUserByUsernameOrEmail: () => getUserByUsernameOrEmail,
  getUserHoverCardProfile: () => getUserHoverCardProfile,
  programQuery: () => programQuery,
  projectsAuthoredByUser: () => projectsAuthoredByUser
});

// src/lib/constants.ts
var KHAN_GRAPHQL_URL = "https://www.khanacademy.org/api/internal/graphql";
var FKEY = `bhavjitchauhan/khan-api_${Date.now()}`;
var PLACEHOLDER_PROGRAM_ID = 4669512406581248;

// src/utils/fetch.ts
async function http(url, init) {
  return await fetch(url, init);
}
async function post(url, body, init) {
  init = { method: "post", body: JSON.stringify(body), ...init };
  return await http(url, init);
}
async function graphql(url, query, variables = {}, init) {
  const body = { query, variables };
  return await post(url, body, init);
}

// src/queries/avatarDataForProfile.ts
var AvatarDataForProfile;
((AvatarDataForProfile2) => {
  AvatarDataForProfile2.query = `query avatarDataForProfile($kaid: String!) {
  user(kaid: $kaid) {
    id
    avatar {
      name
      imageSrc
      __typename
    }
    __typename
  }
}
`;
})(AvatarDataForProfile || (AvatarDataForProfile = {}));
function avatarDataForProfile(variablesOrKaid, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/avatarDataForProfile`,
    AvatarDataForProfile.query,
    typeof variablesOrKaid === "string" ? { kaid: variablesOrKaid } : variablesOrKaid,
    init
  );
}

// src/queries/feedbackQuery.ts
var FeedbackQuery;
((FeedbackQuery2) => {
  FeedbackQuery2.query = `query feedbackQuery($topicId: String!, $focusKind: String!, $cursor: String, $limit: Int, $feedbackType: FeedbackType!, $currentSort: Int, $qaExpandKey: String) {
  feedback(focusId: $topicId, cursor: $cursor, limit: $limit, feedbackType: $feedbackType, focusKind: $focusKind, sort: $currentSort, qaExpandKey: $qaExpandKey, answersLimit: 1) {
    feedback {
      replyCount
      appearsAsDeleted
      author {
        id
        kaid
        nickname
        avatar {
          name
          imageSrc
          __typename
        }
        __typename
      }
      badges {
        name
        icons {
          smallUrl
          __typename
        }
        description
        __typename
      }
      content
      date
      definitelyNotSpam
      deleted
      downVoted
      expandKey
      feedbackType
      flaggedBy
      flaggedByUser
      flags
      focusUrl
      focus {
        kind
        id
        translatedTitle
        relativeUrl
        __typename
      }
      fromVideoAuthor
      key
      lowQualityScore
      notifyOnAnswer
      permalink
      qualityKind
      replyCount
      replyExpandKeys
      showLowQualityNotice
      sumVotesIncremented
      upVoted
      ... on QuestionFeedback {
        hasAnswered
        answers {
          replyCount
          appearsAsDeleted
          author {
            id
            kaid
            nickname
            avatar {
              name
              imageSrc
              __typename
            }
            __typename
          }
          badges {
            name
            icons {
              smallUrl
              __typename
            }
            description
            __typename
          }
          content
          date
          definitelyNotSpam
          deleted
          downVoted
          expandKey
          feedbackType
          flaggedBy
          flaggedByUser
          flags
          focusUrl
          focus {
            kind
            id
            translatedTitle
            relativeUrl
            __typename
          }
          fromVideoAuthor
          key
          lowQualityScore
          notifyOnAnswer
          permalink
          qualityKind
          replyCount
          replyExpandKeys
          showLowQualityNotice
          sumVotesIncremented
          upVoted
          __typename
        }
        isOld
        answerCount
        __typename
      }
      ... on AnswerFeedback {
        question {
          replyCount
          appearsAsDeleted
          author {
            id
            kaid
            nickname
            avatar {
              name
              imageSrc
              __typename
            }
            __typename
          }
          badges {
            name
            icons {
              smallUrl
              __typename
            }
            description
            __typename
          }
          content
          date
          definitelyNotSpam
          deleted
          downVoted
          expandKey
          feedbackType
          flaggedBy
          flaggedByUser
          flags
          focusUrl
          focus {
            kind
            id
            translatedTitle
            relativeUrl
            __typename
          }
          fromVideoAuthor
          key
          lowQualityScore
          notifyOnAnswer
          permalink
          qualityKind
          replyCount
          replyExpandKeys
          showLowQualityNotice
          sumVotesIncremented
          upVoted
          __typename
        }
        __typename
      }
      __typename
    }
    cursor
    isComplete
    sortedByDate
    __typename
  }
}
`;
})(FeedbackQuery || (FeedbackQuery = {}));
function feedbackQuery(variables, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/feedbackQuery`,
    FeedbackQuery.query,
    variables,
    init
  );
}

// src/queries/getFeedbackReplies.ts
var GetFeedbackReplies;
((GetFeedbackReplies2) => {
  GetFeedbackReplies2.query = `query getFeedbackReplies($postKey: String!) {
  feedbackReplies(feedbackKey: $postKey) {
    expandKey
    appearsAsDeleted
    author {
      id
      kaid
      nickname
      avatar {
        name
        imageSrc
        __typename
      }
      __typename
    }
    content
    date
    definitelyNotSpam
    deleted
    downVoted
    expandKey
    feedbackType
    flaggedBy
    flaggedByUser
    flags
    focusUrl
    fromVideoAuthor
    key
    lowQualityScore
    notifyOnAnswer
    permalink
    qualityKind
    replyCount
    replyExpandKeys
    showLowQualityNotice
    sumVotesIncremented
    upVoted
    __typename
  }
}
`;
})(GetFeedbackReplies || (GetFeedbackReplies = {}));
function getFeedbackReplies(variablesOrPostKey, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/getFeedbackReplies`,
    GetFeedbackReplies.query,
    typeof variablesOrPostKey === "string" ? { postKey: variablesOrPostKey } : variablesOrPostKey,
    init
  );
}

// src/utils/format.ts
function truncate(str, length, postfix = "...") {
  length = Math.max(0, length);
  return str.length > length ? str.slice(0, length - postfix.length) + postfix : str;
}
function toStandardBase64(base64) {
  return base64.replace(/-/g, "+").replace(/_/g, "/");
}
function toURLSafeBase64(base64) {
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

// src/utils/regexes.ts
function matchify(regex) {
  return new RegExp(`(${regex.source.slice(1, -1)})`);
}
var KaidRegex = /^kaid_\d{20,25}$/;
var KaidRegexMatch = matchify(KaidRegex);
var isKaid = (str) => KaidRegex.test(str);
var PROGRAM_ID_LENGTHS = [9, 10, 16];
var ProgramIDRegex = new RegExp(
  `^[1-9](?:(?:${PROGRAM_ID_LENGTHS.map((v) => `\\d{${v - 1}}`).join("|")}))$`
);
var ProgramIDRegexMatch = new RegExp(
  `(?:^|\\D)(${ProgramIDRegex.source.slice(1, -1)})(?:$|\\D)`
);
function isProgramID(strOrNum) {
  return ProgramIDRegex.test(strOrNum.toString());
}
var PROGRAM_URL_TLDS = ["com", "org"];
var PROGRAM_URL_LOCALES = [
  "as",
  "az",
  "cs",
  "da",
  "el",
  "gu",
  "hu",
  "id",
  "it",
  "lt",
  "ja",
  "kk",
  "kn",
  "ky",
  "lv",
  "mn",
  "mr",
  "my",
  "nl",
  "pt-pt",
  "ru",
  "sv",
  "ta",
  "uz",
  "bg",
  "bn",
  "de",
  "en",
  "es",
  "fr",
  "hi",
  "hy",
  "ka",
  "km",
  "ko",
  "nb",
  "pa",
  "pl",
  "pt",
  "ro",
  "sr",
  "tr",
  "vi",
  "zh-hans",
  "sgn-us"
];
var PROGRAM_URL_PATHS = [
  "computer-programming",
  "cs",
  "pixar",
  "nasa",
  "piab-sandbox",
  "computer-science",
  "hour-of-code",
  "math",
  "differential-equations",
  "electrical-engineering",
  "mcat",
  "apchem-topic",
  "chemistry",
  "art-history-basics",
  "biology"
];
var ProgramURLRegex = new RegExp(
  `^https?:\\/\\/(?:(?:www|${PROGRAM_URL_LOCALES.join(
    "|"
  )})\\.)?khanacademy\\.(?:${PROGRAM_URL_TLDS.join(
    "|"
  )})\\/(?:${PROGRAM_URL_PATHS.join(
    "|"
  )})\\/[\\w\\d-.~()'!*:@,;]+\\/(${ProgramIDRegex.toString().slice(2, -2)})$`,
  "i"
);
var ProgramURLRegexMatch = matchify(ProgramURLRegex);
function isProgramURL(str) {
  return ProgramURLRegex.test(str);
}
var ProgramImagePathRegex = new RegExp(
  `^\\/(?:${PROGRAM_URL_PATHS.join(
    "|"
  )})\\/[\\w\\d-.~()'!*:@,;]+\\/\\d+\\/(\\d+)\\.png$`
);
var ProgramImagePathRegexMatch = matchify(ProgramImagePathRegex);
var PROGRAM_KEY_LENGTHS = [51, 54];
var ProgramKeyRegex = /^ag5zfmtoYW4tYWNhZGVteXI(?:U|X)CxIKU2NyYXRjaHBhZB(?:i|j)(?=[\w-]*$)(?:.{7}w|.{9}C(?:g|w|A|Q)w)$/;
var ProgramKeyRegexMatch = matchify(ProgramKeyRegex);
function isProgramKey(str) {
  if (PROGRAM_KEY_LENGTHS.includes(str.length))
    return false;
  if (!ProgramKeyRegex.test(str))
    return false;
  try {
    atob(toStandardBase64(str));
    return true;
  } catch {
    return false;
  }
}
var MESSAGE_KEY_LENGTHS = [106, 107, 108, 110, 111];
var FeedbackKeyRegex = /^ag5zfmtoYW4tYWNhZGVteX(?:I|J)(?:A|B|7|9|-|_)CxIIVXNlckRhdGEi(?:Gm|GG|G2|Hm|HG|HW)thaWRf(?:M|N|O)(?:\w{34}|\w{29,31}|\w{27})(?:LEghGZWVkYmFjaxiAg[I-P](?:O|P|W|X|2|3)|DAsSCEZlZWRiYWNrGICA|MCxIIRmVlZGJhY2sYgI(?:C|D)|wLEghGZWVkYmFjaxiAg|DAsSCEZlZWRiYWNrGICA)(?:[\w-]{5}|[\w-]{7,8})(?:M|DA|C(?:g|w|A|Q)w)$/;
var FeedbackKeyRegexMatch = matchify(FeedbackKeyRegex);
var isFeedbackKey = (str) => FeedbackKeyRegex.test(str);
var MESSAGE_ENCRYPTED_KEY_LENGTHS = [301];
var MessageEncryptedKeyRegex = /^kaencrypted_[a-z0-9]{32}_[a-z0-9]{256}$/;
var MessageEncryptedKeyRegexMatch = matchify(MessageEncryptedKeyRegex);
var isEncryptedFeedbackKey = (str) => MessageEncryptedKeyRegex.test(str);
var GoogleIDRegex = /^http:\/\/googleid\.khanacademy\.org\/(\d+)$/;
var GoogleIDRegexMatch = matchify(GoogleIDRegex);
var isGoogleID = (str) => GoogleIDRegex.test(str);
var QualarooIDRegex = /^_gae_bingo_random:(\w+-\w+-\w+)$/;
var QualarooIDRegexMatch = matchify(QualarooIDRegex);
var isQualarooID = (str) => QualarooIDRegex.test(str);
var EmailRegex = /^[a-zA-Z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;
var EmailRegexMatch = matchify(EmailRegex);
var isEmail = (str) => EmailRegex.test(str);

// src/queries/getFullUserProfile.ts
var GetFullUserProfile;
((GetFullUserProfile2) => {
  GetFullUserProfile2.query = `query getFullUserProfile($kaid: String, $username: String) {
  user(kaid: $kaid, username: $username) {
    id
    kaid
    key
    userId
    email
    username
    profileRoot
    gaUserId
    qualarooId
    isPhantom
    isDeveloper: hasPermission(name: "can_do_what_only_admins_can_do")
    isCurator: hasPermission(name: "can_curate_tags", scope: ANY_ON_CURRENT_LOCALE)
    isCreator: hasPermission(name: "has_creator_role", scope: ANY_ON_CURRENT_LOCALE)
    isPublisher: hasPermission(name: "can_publish", scope: ANY_ON_CURRENT_LOCALE)
    isModerator: hasPermission(name: "can_moderate_users", scope: GLOBAL)
    isParent
    isTeacher
    isDataCollectible
    isChild
    isOrphan
    isCoachingLoggedInUser
    canModifyCoaches
    nickname
    hideVisual
    joined
    points
    countVideosCompleted
    bio
    profile {
      accessLevel
      __typename
    }
    soundOn
    muteVideos
    showCaptions
    prefersReducedMotion
    noColorInVideos
    newNotificationCount
    canHellban: hasPermission(name: "can_ban_users", scope: GLOBAL)
    canMessageUsers: hasPermission(name: "can_send_moderator_messages", scope: GLOBAL)
    isSelf: isActor
    hasStudents: hasCoachees
    hasClasses
    hasChildren
    hasCoach
    badgeCounts
    homepageUrl
    isMidsignupPhantom
    includesDistrictOwnedData
    canAccessDistrictsHomepage
    preferredKaLocale {
      id
      kaLocale
      status
      __typename
    }
    underAgeGate {
      parentEmail
      daysUntilCutoff
      approvalGivenAt
      __typename
    }
    authEmails
    signupDataIfUnverified {
      email
      emailBounced
      __typename
    }
    pendingEmailVerifications {
      email
      __typename
    }
    tosAccepted
    shouldShowAgeCheck
    birthMonthYear
    lastLoginCountry
    __typename
  }
  actorIsImpersonatingUser
  isAIGuideEnabled
  hasAccessToAIGuideDev
}
`;
})(GetFullUserProfile || (GetFullUserProfile = {}));
function getFullUserProfile(variablesOrIdentifier, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/getFullUserProfile`,
    GetFullUserProfile.query,
    typeof variablesOrIdentifier === "string" ? isKaid(variablesOrIdentifier) ? { kaid: variablesOrIdentifier } : { username: variablesOrIdentifier } : variablesOrIdentifier,
    init
  );
}

// src/queries/getProfileWidgets.ts
var GetProfileWidgets;
((GetProfileWidgets2) => {
  GetProfileWidgets2.query = `query getProfileWidgets($kaid: String!) {
  user(kaid: $kaid) {
    id
    kaid
    badgeCounts
    isChild
    profile {
      programs {
        id
        authorKaid
        authorNickname
        deleted
        displayableSpinoffCount
        imagePath
        key
        sumVotesIncremented
        translatedTitle: title
        url
        __typename
      }
      __typename
    }
    programs(sort: TOP, pageInfo: {itemsPerPage: 2}) {
      programs {
        id
        authorKaid
        authorNickname
        deleted
        displayableSpinoffCount
        imagePath
        key
        sumVotesIncremented
        translatedTitle: title
        url
        __typename
      }
      __typename
    }
    __typename
  }
  userSummary(kaid: $kaid) {
    statistics {
      answers
      comments
      flags
      projectanswers
      projectquestions
      questions
      replies
      votes
      __typename
    }
    __typename
  }
}
`;
})(GetProfileWidgets || (GetProfileWidgets = {}));
function getProfileWidgets(variablesOrKaid, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/getProfileWidgets`,
    GetProfileWidgets.query,
    typeof variablesOrKaid === "string" && isKaid(variablesOrKaid) ? { kaid: variablesOrKaid } : variablesOrKaid,
    init
  );
}

// src/queries/getUserByUsernameOrEmail.ts
var GetUserByUsernameOrEmail;
((GetUserByUsernameOrEmail2) => {
  GetUserByUsernameOrEmail2.query = `query getUserByUsernameOrEmail($username: String, $email: String) {
  user(username: $username, email: $email) {
    id
    kaid
    __typename
  }
}
`;
})(GetUserByUsernameOrEmail || (GetUserByUsernameOrEmail = {}));
function getUserByUsernameOrEmail(variablesOrIdentifier, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/getUserByUsernameOrEmail`,
    GetUserByUsernameOrEmail.query,
    typeof variablesOrIdentifier === "string" ? isEmail(variablesOrIdentifier) ? { email: variablesOrIdentifier } : { username: variablesOrIdentifier } : variablesOrIdentifier,
    init
  );
}

// src/queries/getUserHoverCardProfile.ts
var GetUserHoverCardProfile;
((GetUserHoverCardProfile2) => {
  GetUserHoverCardProfile2.query = `query getUserHoverCardProfile($kaid: String!) {
  user(kaid: $kaid) {
    id
    nickname
    username
    bio
    avatar {
      name
      imageSrc
      __typename
    }
    points
    isPhantom
    isActor
    isCoachedByActor
    userSummaryIsVisibleToActor
    actorHasUserScopedPermission(capability: CAN_VIEW_USER_IDENTITY)
    __typename
  }
}
`;
})(GetUserHoverCardProfile || (GetUserHoverCardProfile = {}));
function getUserHoverCardProfile(variablesOrKaid, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/getUserHoverCardProfile`,
    GetUserHoverCardProfile.query,
    typeof variablesOrKaid === "string" ? { kaid: variablesOrKaid } : variablesOrKaid,
    init
  );
}

// src/queries/programQuery.ts
var ProgramQuery;
((ProgramQuery2) => {
  ProgramQuery2.query = `query programQuery($programId: String!) {
  programById(id: $programId) {
    byChild
    category
    created
    creatorProfile: author {
      id
      nickname
      profileRoot
      profile {
        accessLevel
        __typename
      }
      __typename
    }
    deleted
    description
    spinoffCount: displayableSpinoffCount
    docsUrlPath
    flags
    flaggedBy: flaggedByKaids
    flaggedByUser: isFlaggedByCurrentUser
    height
    hideFromHotlist
    id
    imagePath
    isProjectOrFork: originIsProject
    isOwner
    kaid: authorKaid
    key
    newUrlPath
    originScratchpad: originProgram {
      deleted
      translatedTitle
      url
      __typename
    }
    restrictPosting
    revision: latestRevision {
      id
      code
      configVersion
      created
      editorType
      folds
      __typename
    }
    slug
    sumVotesIncremented
    title
    topic: parentCurationNode {
      id
      nodeSlug: slug
      relativeUrl
      slug
      translatedTitle
      __typename
    }
    translatedTitle
    url
    userAuthoredContentType
    upVoted
    width
    __typename
  }
}
`;
})(ProgramQuery || (ProgramQuery = {}));
function programQuery(variablesOrProgramId, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/programQuery`,
    ProgramQuery.query,
    typeof variablesOrProgramId === "number" ? { programId: variablesOrProgramId.toString() } : typeof variablesOrProgramId === "string" ? { programId: variablesOrProgramId } : variablesOrProgramId,
    init
  );
}

// src/queries/projectsAuthoredByUser.ts
var ProjectsAuthoredByUser;
((ProjectsAuthoredByUser2) => {
  ProjectsAuthoredByUser2.query = `query projectsAuthoredByUser($kaid: String, $pageInfo: ListProgramsPageInfo, $sort: ListProgramSortOrder) {
  user(kaid: $kaid) {
    id
    programs(pageInfo: $pageInfo, sort: $sort) {
      complete
      cursor
      programs {
        id
        key
        authorKaid
        authorNickname
        displayableSpinoffCount
        imagePath
        sumVotesIncremented
        translatedTitle: title
        url
        __typename
      }
      __typename
    }
    __typename
  }
}
`;
})(ProjectsAuthoredByUser || (ProjectsAuthoredByUser = {}));
function projectsAuthoredByUser(variables, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/projectsAuthoredByUser`,
    ProjectsAuthoredByUser.query,
    variables,
    init
  );
}

// src/queries/QAExpandKeyInfo.ts
var QaExpandKeyInfo;
((QaExpandKeyInfo2) => {
  QaExpandKeyInfo2.query = `query QAExpandKeyInfo($encryptedKey: String) {
  qaExpandKeyInfo(encryptedQaExpandKey: $encryptedKey) {
    feedbackType
    unencryptedKey
    __typename
  }
}
`;
})(QaExpandKeyInfo || (QaExpandKeyInfo = {}));
function QAExpandKeyInfo(variablesOrEncryptedKey, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/QAExpandKeyInfo`,
    QaExpandKeyInfo.query,
    typeof variablesOrEncryptedKey === "string" ? { encryptedKey: variablesOrEncryptedKey } : variablesOrEncryptedKey,
    init
  );
}

// src/mutations/index.ts
var mutations_exports = {};
__export(mutations_exports, {
  LoginWithPasswordMutation: () => LoginWithPasswordMutation,
  loginWithPasswordMutation: () => loginWithPasswordMutation
});

// src/mutations/loginWithPasswordMutation.ts
var LoginWithPasswordMutation;
((LoginWithPasswordMutation2) => {
  LoginWithPasswordMutation2.query = `mutation loginWithPasswordMutation($identifier: String!, $password: String!) {
  loginWithPassword(identifier: $identifier, password: $password) {
    user {
      id
      kaid
      canAccessDistrictsHomepage
      isTeacher
      hasUnresolvedInvitations
      transferAuthToken
      preferredKaLocale {
        id
        kaLocale
        status
        __typename
      }
      __typename
    }
    isFirstLogin
    error {
      code
      __typename
    }
    __typename
  }
}
`;
  let ErrorCode;
  ((ErrorCode2) => {
    ErrorCode2["INVALID_CREDENTIALS"] = "INVALID_CREDENTIALS";
    ErrorCode2["TOO_MANY_ATTEMPTS"] = "TOO_MANY_ATTEMPTS";
  })(ErrorCode = LoginWithPasswordMutation2.ErrorCode || (LoginWithPasswordMutation2.ErrorCode = {}));
})(LoginWithPasswordMutation || (LoginWithPasswordMutation = {}));
function loginWithPasswordMutation(variables, init) {
  return graphql(
    `${KHAN_GRAPHQL_URL}/loginWithPasswordMutation`,
    LoginWithPasswordMutation.query,
    variables,
    {
      // This is required for the request to work, see reference
      headers: {
        "x-ka-fkey": FKEY,
        Cookie: `fkey=${FKEY}`
      },
      ...init
    }
  );
}

// src/lib/Wrapper.ts
var Wrapper = class {
  constructor(clientOrData, data) {
    if (clientOrData instanceof Client)
      this.client = clientOrData;
    else
      data ??= clientOrData;
    if (data)
      this.copy(data);
    return this;
  }
  /**
   * Updates data into the class
   *
   * @param data The data to copy from
   * @returns The class instance
   */
  copy(data) {
    Object.assign(this, data);
    return this;
  }
  /**
   * Updates data from a schema into the instance
   *
   * @param schema The schema to copy from
   * @returns The class instance
   */
  copyFromSchema(schema) {
    this.rawData = {
      ...this.rawData,
      ...schema
    };
    return this.copy(this.transformSchema(schema));
  }
  /**
   * Checks if the schema represents the same instance
   */
  isSchema(schema) {
    return this.is(this.transformSchema(schema));
  }
};

// src/types/enums.ts
var ServiceErrorCode = /* @__PURE__ */ ((ServiceErrorCode2) => {
  ServiceErrorCode2["DOWNSTREAM_SERVICE_ERROR"] = "DOWNSTREAM_SERVICE_ERROR";
  return ServiceErrorCode2;
})(ServiceErrorCode || {});
var ServiceErrorName = /* @__PURE__ */ ((ServiceErrorName2) => {
  ServiceErrorName2["users"] = "users";
  return ServiceErrorName2;
})(ServiceErrorName || {});
var UserAccessLevel = /* @__PURE__ */ ((UserAccessLevel2) => {
  UserAccessLevel2["COACH"] = "COACH";
  UserAccessLevel2["PUBLIC"] = "PUBLIC";
  return UserAccessLevel2;
})(UserAccessLevel || {});
var ProgramEditorType = /* @__PURE__ */ ((ProgramEditorType2) => {
  ProgramEditorType2["pjs"] = "pjs";
  ProgramEditorType2["webpage"] = "webpage";
  ProgramEditorType2["ace_sql"] = "ace_sql";
  ProgramEditorType2["unknown"] = "";
  return ProgramEditorType2;
})(ProgramEditorType || {});
var FeedbackFocusKind = /* @__PURE__ */ ((FeedbackFocusKind2) => {
  FeedbackFocusKind2["Challenge"] = "Challenge";
  FeedbackFocusKind2["Interactive"] = "Interactive";
  FeedbackFocusKind2["Project"] = "Project";
  FeedbackFocusKind2["Scratchpad"] = "Scratchpad";
  FeedbackFocusKind2["Talkthrough"] = "Talkthrough";
  return FeedbackFocusKind2;
})(FeedbackFocusKind || {});
var FeedbackType = /* @__PURE__ */ ((FeedbackType2) => {
  FeedbackType2["ALL_PROJECT_ANSWER"] = "ALL_PROJECT_ANSWER";
  FeedbackType2["ALL_PROJECT_QUESTION"] = "ALL_PROJECT_QUESTION";
  FeedbackType2["ANSWER"] = "ANSWER";
  FeedbackType2["COMMENT"] = "COMMENT";
  FeedbackType2["PROGRAM"] = "PROGRAM";
  FeedbackType2["PROJECTFEEDBACK"] = "PROJECTFEEDBACK";
  FeedbackType2["PROJECT_CRITIQUE_ANSWER"] = "PROJECT_CRITIQUE_ANSWER";
  FeedbackType2["PROJECT_CRITIQUE_QUESTION"] = "PROJECT_CRITIQUE_QUESTION";
  FeedbackType2["PROJECT_EVAL_ANSWER"] = "PROJECT_EVAL_ANSWER";
  FeedbackType2["PROJECT_EVAL_QUESTION"] = "PROJECT_EVAL_QUESTION";
  FeedbackType2["PROJECT_HELP_ANSWER"] = "PROJECT_HELP_ANSWER";
  FeedbackType2["PROJECT_HELP_QUESTION"] = "PROJECT_HELP_QUESTION";
  FeedbackType2["QUESTION"] = "QUESTION";
  FeedbackType2["REPLY"] = "REPLY";
  FeedbackType2["SUGGESTED_CLARIFICATION"] = "SUGGESTED_CLARIFICATION";
  return FeedbackType2;
})(FeedbackType || {});
var FeedbackTypename = /* @__PURE__ */ ((FeedbackTypename2) => {
  FeedbackTypename2["AnswerFeedback"] = "AnswerFeedback";
  FeedbackTypename2["BasicFeedback"] = "BasicFeedback";
  FeedbackTypename2["LowQualityFeedback"] = "LowQualityFeedback";
  FeedbackTypename2["QuestionFeedback"] = "QuestionFeedback";
  return FeedbackTypename2;
})(FeedbackTypename || {});
var FeedbackSort = /* @__PURE__ */ ((FeedbackSort3) => {
  FeedbackSort3[FeedbackSort3["TopVoted"] = 1] = "TopVoted";
  FeedbackSort3[FeedbackSort3["Recent"] = 2] = "Recent";
  return FeedbackSort3;
})(FeedbackSort || {});
var ListProgramSortOrder = /* @__PURE__ */ ((ListProgramSortOrder2) => {
  ListProgramSortOrder2["TOP"] = "TOP";
  ListProgramSortOrder2["RECENT"] = "RECENT";
  return ListProgramSortOrder2;
})(ListProgramSortOrder || {});

// src/User.ts
var User = class extends Wrapper {
  /**
   * Creates a new user from the given from a user schema
   *
   * @description
   * Note that `Client.getUser` will automatically call this method. This is only useful if you need to use the low-level API.
   *
   * @param schema
   *
   * @see {@link Client!Client.getUser}
   */
  static fromSchema(schema) {
    const user = new User();
    user.copyFromSchema(schema);
    user.rawData = schema;
    return user;
  }
  static fromIdentifier(identifier) {
    const user = new User({
      kaid: isKaid(identifier) ? identifier : void 0,
      username: !isKaid(identifier) && !isEmail(identifier) ? identifier : void 0,
      email: isEmail(identifier) ? identifier : void 0
    });
    return user;
  }
  #resolveIdentifier() {
    if (this.kaid)
      return this.kaid;
    if (this.username)
      return this.username;
    if (this.email)
      return this.email;
    throw new Error("User has no identifier");
  }
  transformSchema(schema) {
    return {
      emails: schema.authEmails ?? void 0,
      badgeCounts: schema.badgeCounts ? JSON.parse(schema.badgeCounts) : void 0,
      bio: schema.bio ?? void 0,
      canAccessDistrictsHomepage: schema.canAccessDistrictsHomepage ?? void 0,
      canHellban: schema.canHellban ?? void 0,
      canMessageUsers: schema.canMessageUsers ?? void 0,
      canModifyCoaches: schema.canModifyCoaches ?? void 0,
      completedVideos: schema.countVideosCompleted,
      email: schema.email ?? void 0,
      hasChildren: schema.hasChildren ?? void 0,
      hasClasses: schema.hasClasses ?? void 0,
      hasCoach: schema.hasCoach ?? void 0,
      hasStudents: schema.hasStudents ?? void 0,
      child: schema.isChild ?? void 0,
      creator: schema.isCreator ?? void 0,
      curator: schema.isCurator ?? void 0,
      developer: schema.isDeveloper ?? void 0,
      midsignupPhantom: schema.isMidsignupPhantom ?? void 0,
      moderator: schema.isModerator ?? void 0,
      orphan: schema.isOrphan ?? void 0,
      parent: schema.isParent ?? void 0,
      phantom: schema.isPhantom ?? void 0,
      publisher: schema.isPublisher ?? void 0,
      self: schema.isSelf ?? void 0,
      teacher: schema.isTeacher ?? void 0,
      joined: schema.joined ? new Date(schema.joined) : void 0,
      kaid: typeof schema.kaid === "string" && isKaid(schema.kaid) ? schema.kaid : typeof schema.kaid === "string" ? null : void 0,
      key: schema.key ?? void 0,
      newNotifications: schema.newNotificationCount ?? void 0,
      nickname: schema.nickname ?? void 0,
      points: schema.points ?? void 0,
      accessLevel: schema.profile?.accessLevel,
      googleID: typeof schema.userId === "string" && isGoogleID(schema.userId) ? schema.userId.match(GoogleIDRegex)[1] : typeof schema.userId === "string" ? null : void 0,
      qualarooID: typeof schema.qualarooId === "string" && isQualarooID(schema.qualarooId) ? schema.qualarooId.match(QualarooIDRegex)[1] : typeof schema.qualarooId === "string" ? null : void 0,
      username: schema.username ?? (schema.profileRoot ? !isKaid(schema.profileRoot.slice(9, -1)) ? schema.profileRoot.slice(9, -1) : null : schema.username)
    };
  }
  /**
   * Fetches the user's profile using a `getFullUserProfile` query and updates the user's data
   *
   * @param client Optional client to use for the request
   */
  async get(client = this.client ?? new Client()) {
    const user = await client.getUser(this.#resolveIdentifier());
    return this.copy(user);
  }
  async getAvatar(client = this.client ?? new Client()) {
    const url = await client.getAvatar(this.#resolveIdentifier());
    this.copy({ avatar: url });
    return url;
  }
  async getStatistics(client = this.client ?? new Client()) {
    const statistics = await client.getUserStatistics(this.#resolveIdentifier());
    return this.copy({ statistics });
  }
  /**
   * @see {@link Client!Client.getUserPrograms}
   */
  async *getPrograms(client = this.client ?? new Client(), sort, limit) {
    for await (const programs of client.getUserPrograms(
      this.#resolveIdentifier(),
      sort,
      limit
    )) {
      if (!this.programs)
        this.copy({ programs: [] });
      programs.forEach((program) => this.programs?.push(program));
      yield programs;
    }
    return this;
  }
  /**
   * @see {@link Client!Client.getAllUserPrograms}
   */
  async getAllPrograms(client = this.client ?? new Client(), sort, limit) {
    const programs = await client.getAllUserPrograms(
      this.#resolveIdentifier(),
      sort,
      limit
    );
    return this.copy({ programs });
  }
  /**
   * Checks if two users are the same
   *
   * @param user The user to compare to
   */
  is(user) {
    if (!(this.kaid && user.kaid) && !(this.email && user.email) && !(this.key && user.key) && !(this.username && user.username) && !(this.googleID && user.googleID) && !(this.qualarooID && user.qualarooID)) {
      console.warn("Users don't have any identifiers that can be compared");
      return false;
    }
    return this.kaid && user.kaid && this.kaid === user.kaid || this.email && user.email && this.email === user.email || this.key && user.key && this.key === user.key || this.username && user.username && this.username === user.username || this.googleID && user.googleID && this.googleID === user.googleID || this.qualarooID && user.qualarooID && this.qualarooID === user.qualarooID || false;
  }
};

// src/types/responses.ts
function isDataResponse(response) {
  return "data" in response && !("errors" in response);
}
function isServiceErrorsResponse(response) {
  return "errors" in response && Array.isArray(response.errors) && "data" in response;
}
function isInputErrorResponse(response) {
  return "errors" in response && Array.isArray(response.errors) && !("data" in response);
}
function assertDataResponse(response) {
  if (isServiceErrorsResponse(response))
    throw new Error(
      "Expected data response but got service errors response: " + response.errors.map((error) => error.message).join(", ")
    );
  if (isInputErrorResponse(response))
    throw new Error(
      "Expected data response but got input errors response: " + response.errors.map((error) => error.message).join(", ")
    );
  if (!isDataResponse(response))
    throw new Error("Expected data response but got unknown response");
}

// src/utils/programs.ts
function programKeyToID(key) {
  if (!isProgramKey(key))
    throw new Error("Invalid program key");
  let bytes = atob(toStandardBase64(key)).split("").map((char) => char.charCodeAt(0));
  const version = bytes[17];
  if (version === 20)
    bytes = bytes.slice(32, 37);
  else if (version === 23)
    bytes = bytes.slice(34, 40);
  else
    throw new Error(`Unknown program key version: ${version}`);
  let result = 0n;
  for (let i = 0; i < bytes.length; i++) {
    result |= BigInt(bytes[i] & 127) << BigInt(i * 7);
  }
  return Number(version === 20 ? result : result << 14n);
}
function programIDtoKey(id) {
  if (!isProgramID(id))
    throw new Error("Invalid program ID");
  if (typeof id === "string")
    id = parseInt(id);
  const encoded = id.toString(2).match(/.{1,7}(?=(.{7})*$)/g).map((r) => String.fromCharCode(parseInt(r.length === 7 ? `1${r}` : r, 2))).reverse().join("");
  let base64 = btoa(
    `js~khan-academyr${encoded.length === 5 ? "" : ""}\v
Scratchpad${encoded}\f`
  );
  base64 = toURLSafeBase64(base64);
  return base64;
}

// src/utils/resolvers.ts
async function resolveKaid(identifier) {
  if (isKaid(identifier))
    return identifier;
  const response = await getUserByUsernameOrEmail(identifier);
  const json = await response.json();
  assertDataResponse(json);
  if (!json.data.user)
    throw new Error("User not found");
  const kaid = json.data.user.kaid;
  if (!isKaid(kaid))
    throw new Error("User does not have a valid KAID");
  return kaid;
}
async function resolveUsername(identifier) {
  if (!isKaid(identifier) && !isEmail(identifier))
    return identifier;
  if (!isKaid(identifier))
    identifier = await resolveKaid(identifier);
  const response = await getUserHoverCardProfile(identifier);
  const json = await response.json();
  assertDataResponse(json);
  if (!json.data.user)
    throw new Error("User not found");
  return json.data.user.username;
}
function resolveProgramID(identifier) {
  if (typeof identifier === "number") {
    if (!isProgramID(identifier))
      throw new Error("Invalid program ID");
    return identifier;
  } else if (isProgramURL(identifier)) {
    const str = identifier.match(ProgramURLRegex)[1];
    if (!isProgramID(str))
      throw new Error("Invalid program URL");
    return parseInt(str, 10);
  } else if (isProgramKey(identifier)) {
    identifier = programKeyToID(identifier);
    if (!isProgramID(identifier))
      throw new Error("Invalid program key");
    return identifier;
  } else if (typeof identifier === "string") {
    if (!isProgramID(identifier))
      throw new Error("Invalid program ID");
    return parseInt(identifier, 10);
  }
  throw new Error("Invalid program identifier");
}
async function resolveFeedbackKey(identifier) {
  if (isFeedbackKey(identifier))
    return identifier;
  if (!isEncryptedFeedbackKey(identifier))
    throw new Error("Invalid encrypted message key");
  const response = await QAExpandKeyInfo(identifier);
  const json = await response.json();
  assertDataResponse(json);
  if (!json.data.qaExpandKeyInfo)
    throw new Error("Message key not found");
  return json.data.qaExpandKeyInfo.unencryptedKey;
}

// src/Program.ts
var ProgramType = /* @__PURE__ */ ((ProgramType2) => {
  ProgramType2["ProcessingJS"] = "pjs";
  ProgramType2["HTML"] = "webpage";
  ProgramType2["SQL"] = "ace_sql";
  ProgramType2["Other"] = "";
  return ProgramType2;
})(ProgramType || {});
var _resolveIdentifier, resolveIdentifier_fn;
var _Program = class extends Wrapper {
  constructor() {
    super(...arguments);
    __privateAdd(this, _resolveIdentifier);
  }
  get spinoff() {
    return typeof this.origin !== "undefined" ? !!this.origin : null;
  }
  /**
   * Number of lines of code in the program.
   */
  get lines() {
    if (this.code)
      return this.code.split("\n").length;
    return null;
  }
  /**
   * URL of the program.
   */
  get url() {
    if (this.rawData?.url)
      return `https://www.khanacademy.org${this.rawData.url}`;
    if (this.id)
      return `https://www.khanacademy.org/computer-programming/-/${this.id}`;
    return null;
  }
  /**
   * Short URL of the program.
   */
  get shortUrl() {
    if (this.id)
      return `https://khanacademy.org/cs/-/${this.id}`;
    return null;
  }
  /**
   * Thumbnail image URL of the program.
   *
   * @description
   * To get the latest thumbnail image, use 'latest' as the thumbnail ID instead.
   */
  get thumbnailUrl() {
    if (this.rawData?.imagePath)
      return `https://www.khanacademy.org${this.rawData.imagePath}`;
    if (this.thumbnailID && this.url)
      return `${this.url}/${this.thumbnailID}.png`;
    return null;
  }
  static fromSchema(schema) {
    const program = new _Program();
    program.copyFromSchema(schema);
    program.rawData = schema;
    return program;
  }
  static fromIdentifier(identifier) {
    const id = resolveProgramID(identifier);
    const program = new _Program({
      id,
      key: typeof identifier === "string" && isProgramKey(identifier) ? identifier : void 0
    });
    return program;
  }
  transformSchema(schema) {
    return {
      id: schema.id ? parseInt(schema.id, 10) : void 0,
      title: schema.translatedTitle,
      author: schema.authorKaid || schema.authorNickname || schema.creatorProfile ? User.fromSchema({
        kaid: schema.authorKaid,
        nickname: schema.authorNickname,
        isChild: schema.byChild ?? void 0,
        ...schema.creatorProfile
      }) : void 0,
      created: (() => {
        if (!schema.created)
          return void 0;
        if (schema.revision?.created) {
          return new Date(
            Math.min(
              new Date(schema.created).valueOf(),
              new Date(schema.revision.created).valueOf()
            )
          );
        }
        return new Date(schema.created);
      })(),
      updated: (() => {
        if (!schema.revision?.created)
          return void 0;
        if (schema.created && schema.revision.created === schema.created)
          return null;
        return new Date(schema.revision.created);
      })(),
      width: schema.width,
      height: schema.height,
      votes: schema.sumVotesIncremented,
      spinOffCount: schema.spinoffCount ?? schema.displayableSpinoffCount,
      code: schema.revision?.code,
      hidden: schema.hideFromHotlist,
      type: (() => {
        switch (schema.revision?.editorType) {
          case "pjs" /* pjs */:
            return _Program.Type.ProcessingJS;
          case "webpage" /* webpage */:
            return _Program.Type.HTML;
          case "ace_sql" /* ace_sql */:
            return _Program.Type.SQL;
          default:
            return _Program.Type.Other;
        }
      })(),
      origin: (() => {
        if (!schema.originScratchpad)
          return schema.originScratchpad;
        const id = ("https://khanacademy.org" + schema.originScratchpad.url).match(ProgramURLRegex)?.[1];
        if (!id) {
          console.error(
            `Failed to parse origin program ID from URL: ${schema.originScratchpad.url}`
          );
          return void 0;
        }
        return new _Program({
          id: parseInt(id, 10),
          title: schema.originScratchpad.translatedTitle,
          deleted: schema.originScratchpad.deleted
        });
      })(),
      key: schema.key,
      thumbnailID: schema.imagePath && ProgramImagePathRegex.test(schema.imagePath) ? parseInt(schema.imagePath.match(ProgramImagePathRegex)[1], 10) : void 0,
      description: typeof schema.description === "string" ? schema.description !== "" ? schema.description : null : schema.description,
      deleted: schema.deleted ?? void 0,
      selfFlagged: schema.flaggedByUser,
      selfVoted: schema.upVoted
    };
  }
  async get(client = this.client ?? new Client()) {
    if (!this.id && !this.key)
      throw new Error("Program is missing ID and key");
    const data = await client.getProgram(this.id ?? this.key);
    return this.copy(data);
  }
  async *getTipsAndThanks(client = this.client ?? new Client(), sort) {
    for await (const messages of client.getProgramTipsAndThanks(
      __privateMethod(this, _resolveIdentifier, resolveIdentifier_fn).call(this),
      sort
    )) {
      if (!this.tipsAndThanks)
        this.copy({ tipsAndThanks: [] });
      messages.forEach((message) => this.tipsAndThanks?.push(message));
      yield messages;
    }
    return this;
  }
  async getAllTipsAndThanks(client = this.client ?? new Client(), sort) {
    const messages = await client.getAllProgramTipsAndThanks(
      __privateMethod(this, _resolveIdentifier, resolveIdentifier_fn).call(this),
      sort
    );
    return this.copy({ tipsAndThanks: messages });
  }
  async *getQuestions(client = this.client ?? new Client(), sort) {
    for await (const messages of client.getProgramQuestions(
      __privateMethod(this, _resolveIdentifier, resolveIdentifier_fn).call(this),
      sort
    )) {
      if (!this.questions)
        this.copy({ questions: [] });
      messages.forEach((message) => this.questions.push(message));
      yield messages;
    }
    return this;
  }
  async getAllQuestions(client = this.client ?? new Client(), sort) {
    const messages = await client.getAllProgramQuestions(
      __privateMethod(this, _resolveIdentifier, resolveIdentifier_fn).call(this),
      sort
    );
    return this.copy({ questions: messages });
  }
  async *getHelpRequests(client = this.client ?? new Client(), sort) {
    for await (const messages of client.getProgramHelpRequests(
      __privateMethod(this, _resolveIdentifier, resolveIdentifier_fn).call(this),
      sort
    )) {
      if (!this.helpRequests)
        this.copy({ helpRequests: [] });
      messages.forEach((message) => this.helpRequests.push(message));
      yield messages;
    }
    return this;
  }
  async getAllHelpRequests(client = this.client ?? new Client(), sort) {
    const messages = await client.getAllProgramHelpRequests(
      __privateMethod(this, _resolveIdentifier, resolveIdentifier_fn).call(this),
      sort
    );
    return this.copy({ helpRequests: messages });
  }
  is(program) {
    if (!(this.id && program.id) && !(this.key && program.key)) {
      console.warn("Programs don't have any identifiers that can be compared");
      return false;
    }
    return this.id && program.id && this.id === program.id || this.key && program.key && this.key === program.key || false;
  }
};
var Program = _Program;
_resolveIdentifier = new WeakSet();
resolveIdentifier_fn = function() {
  if (this.id)
    return this.id;
  if (this.key)
    return this.key;
  throw new Error("Program has no identifier");
};
/**
 * Aliases for the program types.
 *
 * @rawEquivalent {@link types/schema!ProgramRevisionSchema.editorType}
 */
Program.Type = ProgramType;

// src/utils/avatars.ts
var avatarNames = [
  "blobby_green_style",
  "blobby_yellow_style",
  "blobby_blue_style",
  "blobby_purple_style",
  "area_52_yellow_style",
  "area_52_blue_style",
  "area_52_green_style",
  "area_52_purple_style",
  "eggleston_blue_style",
  "eggleston_yellow_style",
  "eggleston_green_style",
  "eggleston_orange_style",
  "scuttlebug_purple_style",
  "scuttlebug_yellow_style",
  "scuttlebug_blue_style",
  "scuttlebug_green_style",
  "boggle_yellow_style",
  "boggle_blue_style",
  "boggle_green_style",
  "boggle_purple_style",
  "sneak_peak_green_style",
  "sneak_peak_yellow_style",
  "sneak_peak_blue_style",
  "sneak_peak_purple_style",
  "stelly_blue_style",
  "stelly_yellow_style",
  "stelly_green_style",
  "stelly_orange_style",
  "cacteye_purple_style",
  "cacteye_yellow_style",
  "cacteye_blue_style",
  "cacteye_green_style",
  "leaf_green_style",
  "leaf_blue_style",
  "leaf_grey_style",
  "leaf_red_style",
  "leaf_orange_style",
  "leaf_yellow_style",
  "leafers_seed_style",
  "leafers_seedling_style",
  "leafers_sapling_style",
  "leafers_tree_style",
  "leafers_ultimate_style",
  "piceratops_seed_style",
  "piceratops_seedling_style",
  "piceratops_sapling_style",
  "piceratops_tree_style",
  "piceratops_ultimate_style",
  "duskpin_seed_style",
  "duskpin_seedling_style",
  "duskpin_sapling_style",
  "duskpin_tree_style",
  "duskpin_ultimate_style",
  "primosaur_seed_style",
  "primosaur_seedling_style",
  "primosaur_sapling_style",
  "primosaur_tree_style",
  "primosaur_ultimate_style",
  "starky_seed_style",
  "starky_seedling_style",
  "starky_sapling_style",
  "starky_tree_style",
  "starky_ultimate_style",
  "aqualine_seed_style",
  "aqualine_seedling_style",
  "aqualine_sapling_style",
  "aqualine_tree_style",
  "aqualine_ultimate_style",
  "spunky_sam_blue_style",
  "spunky_sam_green_style",
  "spunky_sam_orange_style",
  "spunky_sam_red_style",
  "marcimus_pink_style",
  "marcimus_orange_style",
  "marcimus_red_style",
  "marcimus_purple_style",
  "mr_pink_red_style",
  "mr_pink_green_style",
  "mr_pink_orange_style",
  "female_robot_amelia_style",
  "female_robot_ada_style",
  "female_robot_grace_style",
  "male_robot_johnny_style",
  "male_robot_donald_style",
  "male_robot_hal_style",
  "orange_juice_squid_orange_style",
  "purple_pi_purple_style",
  "purple_pi_pink_style",
  "purple_pi_teal_style",
  "mr_pants_teal_style",
  "mr_pants_green_style",
  "mr_pants_orange_style",
  "mr_pants_pink_style",
  "mr_pants_purple_style",
  "old_spice_man_green_style",
  "old_spice_man_blue_style",
  "winston_default_style",
  "winston_baby_style",
  "ohnoes_default_style",
  "hopper_happy_style",
  "hopper_jumping_style",
  "hopper_cool_style"
];
var avatarSlugs = [
  "blobby-green",
  "blobby-yellow",
  "blobby-blue",
  "blobby-purple",
  "area-52-yellow",
  "area-52-blue",
  "area-52-green",
  "area-52-purple",
  "eggleston-blue",
  "eggleston-yellow",
  "eggleston-green",
  "eggleston-orange",
  "scuttlebug-purple",
  "scuttlebug-yellow",
  "scuttlebug-blue",
  "scuttlebug-green",
  "boggle-yellow",
  "boggle-blue",
  "boggle-green",
  "boggle-purple",
  "sneak-peak-green",
  "sneak-peak-yellow",
  "sneak-peak-blue",
  "sneak-peak-purple",
  "stelly-blue",
  "stelly-yellow",
  "stelly-green",
  "stelly-orange",
  "cacteye-purple",
  "cacteye-yellow",
  "cacteye-blue",
  "cacteye-green",
  "leaf-green",
  "leaf-blue",
  "leaf-grey",
  "leaf-red",
  "leaf-orange",
  "leaf-yellow",
  "leafers-seed",
  "leafers-seedling",
  "leafers-sapling",
  "leafers-tree",
  "leafers-ultimate",
  "piceratops-seed",
  "piceratops-seedling",
  "piceratops-sapling",
  "piceratops-tree",
  "piceratops-ultimate",
  "duskpin-seed",
  "duskpin-seedling",
  "duskpin-sapling",
  "duskpin-tree",
  "duskpin-ultimate",
  "primosaur-seed",
  "primosaur-seedling",
  "primosaur-sapling",
  "primosaur-tree",
  "primosaur-ultimate",
  "starky-seed",
  "starky-seedling",
  "starky-sapling",
  "starky-tree",
  "starky-ultimate",
  "aqualine-seed",
  "aqualine-seedling",
  "aqualine-sapling",
  "aqualine-tree",
  "aqualine-ultimate",
  "spunky-sam",
  "spunky-sam-green",
  "spunky-sam-orange",
  "spunky-sam-red",
  "marcimus",
  "marcimus-orange",
  "marcimus-red",
  "marcimus-purple",
  "mr-pink",
  "mr-pink-green",
  "mr-pink-orange",
  "robot_female_1",
  "robot_female_2",
  "robot_female_3",
  "robot_male_1",
  "robot_male_2",
  "robot_male_3",
  "orange-juice-squid",
  "purple-pi",
  "purple-pi-pink",
  "purple-pi-teal",
  "mr-pants",
  "mr-pants-green",
  "mr-pants-orange",
  "mr-pants-pink",
  "mr-pants-purple",
  "old-spice-man",
  "old-spice-man-blue",
  "cs-winston",
  "cs-winston-baby",
  "cs-ohnoes",
  "cs-hopper-happy",
  "cs-hopper-jumping",
  "cs-hopper-cool"
];
function avatarNameToSlug(name) {
  return avatarSlugs[avatarNames.indexOf(name)];
}
function avatarSlugToName(slug) {
  return avatarNames[avatarSlugs.indexOf(slug)];
}
function generateAvatarSVG(slug) {
  return `https://www.khanacademy.org/images/avatars/svg/${slug}.svg`;
}
function generateAvatarPNG(slug) {
  return `https://www.khanacademy.org/images/avatars/${slug}.png`;
}
function extractAvatarSlug(path) {
  return path.match(
    /^(?:https:\/\/www\.khanacademy\.org)?\/images\/avatars(?:\/svg)?\/(.*)\.(?:(?:svg)|(?:png))$/
  )?.[1] ?? null;
}
function convertAvatarSVGToPNG(url) {
  const slug = extractAvatarSlug(url);
  if (!slug)
    return null;
  return generateAvatarPNG(slug);
}
function convertAvatarPNGToSVG(url) {
  const slug = extractAvatarSlug(url);
  if (!slug)
    return null;
  return generateAvatarSVG(slug);
}

// src/utils/cookies.ts
function stripCookies(cookies) {
  return cookies.replace(/[a-zA-Z]+, \d\d [A-Za-z0-9]+ \d{4} \d\d:\d\d:\d\d [a-zA-Z]+/g, "").replace(/; (Path|Expires|Max-Age|HttpOnly|Secure|SameSite)[^;,]*/g, "").replace(/,/g, ";");
}

// src/lib/messages/BaseMessage.ts
var BaseMessage = class extends Wrapper {
  /**
   * Checks if the message was written by the client user
   */
  get bySelf() {
    return this.client?.user ? this.byUser(this.client.user) : false;
  }
  transformSchema(schema) {
    return {
      text: schema.content,
      author: schema.author && User.fromSchema(schema.author),
      program: (() => {
        if (schema.focus?.kind === "Scratchpad" /* Scratchpad */)
          return new Program({
            id: typeof schema.focus.id === "string" ? parseInt(schema.focus.id, 10) : void 0,
            title: schema.focus.translatedTitle
          });
        if (schema.focusUrl) {
          const matches = schema.focusUrl.match(ProgramIDRegexMatch);
          if (!matches || matches.length < 1)
            return;
          return new Program({
            id: parseInt(matches[1], 10)
          });
        }
      })(),
      created: schema.date ? new Date(schema.date) : void 0,
      key: schema.expandKey,
      encryptedKey: schema.key,
      deleted: schema.appearsAsDeleted,
      verified: schema.definitelyNotSpam,
      score: schema.lowQualityScore,
      byVideoAuthor: schema.fromVideoAuthor,
      selfFlagged: schema.flaggedByUser
    };
  }
  /**
   * Checks if the message was written by the given user
   */
  byUser(user) {
    return this.author ? this.author.is(user) : false;
  }
  /**
   * Checks if the message is the same as the given message
   */
  is(message) {
    if (!(this.key && message.key) && !(this.encryptedKey && message.encryptedKey)) {
      console.warn("Messages don't have any identifiers that can be compared");
      return false;
    }
    return this.key && message.key && this.key === message.key || this.encryptedKey && message.encryptedKey && this.encryptedKey === message.encryptedKey || false;
  }
};

// src/lib/messages/Message.ts
var MessageType = ((MessageType2) => {
  MessageType2[MessageType2["TipsAndThanks"] = "COMMENT" /* COMMENT */] = "TipsAndThanks";
  MessageType2[MessageType2["Question"] = "QUESTION" /* QUESTION */] = "Question";
  MessageType2[MessageType2["HelpRequest"] = "PROJECT_HELP_QUESTION" /* PROJECT_HELP_QUESTION */] = "HelpRequest";
  return MessageType2;
})(MessageType || {});
var _Message = class extends BaseMessage {
  /**
   * @returns `1` if the message was upvoted by the user, `-1` if it was downvoted,
   * and `0` if it was not voted on. `null` if the user is not logged in.
   *
   * @see {@link lib/messages/Message!Message.selfUpvoted}
   * @see {@link lib/messages/Message!Message.selfDownvoted}
   */
  get selfVoted() {
    if (this.client?.authenticated === false)
      return null;
    return this.selfUpvoted ? 1 : this.selfDownvoted ? -1 : 0;
  }
  static fromSchema(schema) {
    const message = new _Message();
    message.copyFromSchema(schema);
    message.rawData = schema;
    return message;
  }
  static fromIdentifier(identifier) {
    const message = new _Message({
      key: isFeedbackKey(identifier) ? identifier : void 0,
      encryptedKey: isEncryptedFeedbackKey(identifier) ? identifier : void 0
    });
    return message;
  }
  transformSchema(schema) {
    return {
      ...super.transformSchema(schema),
      votes: schema.sumVotesIncremented,
      replyCount: schema.replyCount,
      selfUpvoted: schema.upVoted,
      selfDownvoted: schema.downVoted
    };
  }
  copy(message) {
    return super.copy(message);
  }
  async get(client = this.client ?? new Client()) {
    if (!this.key && !this.encryptedKey)
      throw new Error("Message does not have a key or encrypted key");
    const comment = await client.getMessage(this.key ?? this.encryptedKey);
    return this.copy(comment);
  }
  async getAllReplies(client = this.client ?? new Client()) {
    if (!this.key && !this.encryptedKey)
      throw new Error("Message does not have a key or encrypted key");
    const replies = await client.getAllMessageReplies(
      this.key ?? this.encryptedKey
    );
    return this.copy({ replies });
  }
};
var Message = _Message;
/**
 * Aliases for the message types.
 */
Message.Type = MessageType;

// src/lib/messages/Answer.ts
var Answer = class extends Message {
  static fromSchema(schema) {
    const answer = new Answer();
    answer.copyFromSchema(schema);
    answer.rawData = schema;
    return answer;
  }
  static fromIdentifier(identifier) {
    const answer = new Answer({
      key: isFeedbackKey(identifier) ? identifier : void 0,
      encryptedKey: isEncryptedFeedbackKey(identifier) ? identifier : void 0
    });
    return answer;
  }
  transformSchema(schema) {
    return {
      ...super.transformSchema(schema),
      question: schema.question ? Question.fromSchema(
        // If only TypeScript had built-in support for recursive types...
        schema.question
      ) : void 0
    };
  }
  copy(answer) {
    return super.copy(answer);
  }
};

// src/lib/messages/Question.ts
var Question = class extends Message {
  static fromSchema(schema) {
    const question = new Question();
    question.copyFromSchema(schema);
    question.rawData = schema;
    return question;
  }
  static fromIdentifier(identifier) {
    const question = new Question({
      key: isFeedbackKey(identifier) ? identifier : void 0,
      encryptedKey: isEncryptedFeedbackKey(identifier) ? identifier : void 0
    });
    return question;
  }
  transformSchema(schema) {
    return {
      ...super.transformSchema(schema),
      answerCount: schema.answerCount,
      old: schema.isOld,
      answers: (() => {
        if (!schema.answers)
          return void 0;
        const answers = schema.answers.map(
          (answer) => Answer.fromSchema(answer)
        );
        answers.forEach((answer) => answer.copy({ question: this }));
        return answers;
      })()
    };
  }
  copy(question) {
    return super.copy(question);
  }
};

// src/lib/messages/Reply.ts
var Reply = class extends BaseMessage {
  static fromSchema(schema) {
    const reply = new Reply();
    reply.copyFromSchema(schema);
    reply.rawData = schema;
    return reply;
  }
  static fromIdentifier(identifier) {
    const reply = new Reply({
      key: isFeedbackKey(identifier) ? identifier : void 0,
      encryptedKey: isEncryptedFeedbackKey(identifier) ? identifier : void 0
    });
    return reply;
  }
  transformSchema(schema) {
    return {
      ...super.transformSchema(schema),
      message: (() => {
        if (typeof schema.replyExpandKeys === "undefined")
          return;
        if (typeof schema.replyExpandKeys === "string" && isFeedbackKey(schema.replyExpandKeys))
          return new Message({ key: schema.replyExpandKeys });
        if (Array.isArray(schema.replyExpandKeys))
          return new Message({ key: schema.replyExpandKeys[0] });
      })()
    };
  }
  copy(reply) {
    return super.copy(reply);
  }
  /**
   * Updates data from a schema into the instance
   *
   * @param schema The schema to copy from
   * @returns The class instance
   */
  copyFromSchema(schema) {
    return super.copyFromSchema(schema);
  }
  async get(client = this.client ?? new Client()) {
    if (!this.key && !this.encryptedKey)
      throw new Error("Message does not have a key or encrypted key");
    const comment = await client.getMessage(this.key ?? this.encryptedKey);
    return this.copy(comment);
  }
};

// src/lib/messages/TipsAndThanks.ts
var TipsAndThanks = class extends Message {
  static fromSchema(schema) {
    const message = new TipsAndThanks();
    message.copyFromSchema(schema);
    message.rawData = schema;
    return message;
  }
  static fromIdentifier(identifier) {
    const message = new TipsAndThanks({
      key: isFeedbackKey(identifier) ? identifier : void 0,
      encryptedKey: isEncryptedFeedbackKey(identifier) ? identifier : void 0
    });
    return message;
  }
  transformSchema(schema) {
    return {
      ...super.transformSchema(schema),
      votes: schema.sumVotesIncremented,
      replyCount: schema.replyCount,
      selfUpvoted: schema.upVoted,
      selfDownvoted: schema.downVoted
    };
  }
  copy(tipsAndThanks) {
    return super.copy(tipsAndThanks);
  }
};

// src/utils/messages.ts
function isTipsAndThanksSchema(schema) {
  return schema.feedbackType === "COMMENT" /* COMMENT */;
}
function isReplySchema(schema) {
  return schema.feedbackType === "REPLY" /* REPLY */;
}
function isQuestionSchema(schema) {
  return schema.feedbackType === "QUESTION" /* QUESTION */;
}
function isAnswerSchema(schema) {
  return schema.feedbackType === "ANSWER" /* ANSWER */;
}
var TypeToClass = {
  [MessageType.TipsAndThanks]: TipsAndThanks,
  [MessageType.Question]: Question,
  [MessageType.HelpRequest]: Question
};

// src/Client.ts
var _identifier, _password, _cookies, _cachedKaids, _cachedUsernames, _cachedFeedbackKeys, _resolveJsonReponse, resolveJsonReponse_fn;
var _Client = class {
  /**
   * Creates a new Client instance
   *
   * @example
   * const client = new Client()
   */
  constructor() {
    __privateAdd(this, _identifier, void 0);
    __privateAdd(this, _password, void 0);
    __privateAdd(this, _cookies, void 0);
    __privateAdd(this, _cachedKaids, /* @__PURE__ */ new Map());
    __privateAdd(this, _cachedUsernames, /* @__PURE__ */ new Map());
    __privateAdd(this, _cachedFeedbackKeys, /* @__PURE__ */ new Map());
    this.authenticated = false;
    this.kaid = null;
    return this;
  }
  /**
   * Resolves a username or email to a KAID and caches the result
   *
   * @remarks
   * If the identifier is cached, it will be returned immediately. Otherwise a
   * `getUserByUsernameOrEmail` request will be made to resolve the identifier
   *
   * @see {@link utils/resolvers!resolveKaid}
   *
   * @example
   * const getKaid = async () => await client.resolveCachedKaid('bhavjitChauhan')
   * console.log(await getKaid()) // Makes a request
   * console.log(await getKaid()) // Returns cached result
   */
  async resolveCachedKaid(identifier) {
    if (isKaid(identifier))
      return identifier;
    if (__privateGet(this, _cachedKaids).has(identifier))
      return __privateGet(this, _cachedKaids).get(identifier);
    const kaid = await resolveKaid(identifier);
    __privateGet(this, _cachedKaids).set(identifier, kaid);
    return kaid;
  }
  /**
   * Resolves a KAID to a username and caches the result
   *
   * @remarks
   * If the identifier is cached, it will be returned immediately. Otherwise a
   * `getUserHoverCardProfile` request will be made to resolve the identifier
   *
   * @see {@link utils/resolvers!resolveUsername}
   *
   * @example
   * const getUsername = async () => await client.resolveCachedUsername('kaid_376749826184384230772276')
   * console.log(await getUsername()) // Makes a request
   * console.log(await getUsername()) // Returns cached result
   */
  async resolveCachedUsername(identifier) {
    if (!isKaid(identifier) && !isEmail(identifier))
      return identifier;
    if (__privateGet(this, _cachedUsernames).has(identifier))
      return __privateGet(this, _cachedUsernames).get(identifier);
    const username = await resolveUsername(identifier);
    __privateGet(this, _cachedUsernames).set(identifier, username);
    return username;
  }
  /**
   * Resolved an encrypted message key to an unencrypted message key and caches
   * the result
   *
   * @remarks
   * If the identifier is cached, it will be returned immediately. Otherwise a
   * `QAExpandKeyInfo` request will be made to resolve the identifier
   *
   * @see {@link utils/resolvers!resolveFeedbackKey}
   */
  async resolveCachedFeedbackKey(identifier) {
    if (isFeedbackKey(identifier))
      return identifier;
    if (__privateGet(this, _cachedFeedbackKeys).has(identifier))
      return __privateGet(this, _cachedFeedbackKeys).get(identifier);
    const feedbackKey = await resolveFeedbackKey(identifier);
    __privateGet(this, _cachedFeedbackKeys).set(identifier, feedbackKey);
    return feedbackKey;
  }
  /**
   * Gets the KAAS cookie from the current session
   *
   * @remarks
   * The KAAS cookie is used by Khan Academy to authenticate requests.
   *
   * @returns KAAS cookie or null if not authenticated
   */
  get kaas() {
    if (!this.authenticated || !__privateGet(this, _cookies))
      return null;
    return __privateGet(this, _cookies).match(/KAAS=([^;]+)/)?.[1] ?? null;
  }
  /**
   * Logs in to Khan Academy and stores the KAAS cookie
   *
   * @param identifier KAID, username or email
   * @param password
   */
  async login(identifier, password) {
    var _a;
    if (identifier) {
      if (isKaid(identifier))
        identifier = await this.resolveCachedUsername(identifier);
      __privateSet(this, _identifier, identifier);
    }
    if (password)
      __privateSet(this, _password, password);
    if (!__privateGet(this, _identifier) || !__privateGet(this, _password)) {
      if (!__privateGet(this, _identifier))
        throw new Error("Missing username or email");
      if (!__privateGet(this, _password))
        throw new Error("Missing password");
      throw new Error("Missing username/email and password");
    }
    const response = await loginWithPasswordMutation(
      {
        identifier: __privateGet(this, _identifier),
        password: __privateGet(this, _password)
      },
      { credentials: "include" }
    );
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.loginWithPassword)
      throw new Error("Malformed response");
    if (json.data.loginWithPassword.error)
      switch (json.data.loginWithPassword.error.code) {
        case LoginWithPasswordMutation.ErrorCode.INVALID_CREDENTIALS:
          throw new Error(
            "Invalid Credentials error: Check your username/email and password"
          );
        case LoginWithPasswordMutation.ErrorCode.TOO_MANY_ATTEMPTS:
          throw new Error(
            "Too Many Attempts error: Rate-limited by Khan Academy"
          );
        default: {
          throw new Error(
            "Unknown error code: " + json.data.loginWithPassword.error.code
          );
        }
      }
    const cookies = response.headers.get("set-cookie");
    if (!cookies)
      throw new Error(
        "No cookies returned: Something went wrong on Khan Academy's end"
      );
    __privateSet(this, _cookies, stripCookies(cookies));
    this.authenticated = true;
    this.kaid = typeof json.data.loginWithPassword.user?.kaid === "string" && isKaid(json.data.loginWithPassword.user.kaid) ? json.data.loginWithPassword.user.kaid : null;
    if (this.kaid === null)
      console.warn(
        `User ${identifier ?? this.kaas ?? "unknown"} does not have a valid KAID`
      );
    return json.data.loginWithPassword;
  }
  /**
   * @param identifier KAID, username or email
   */
  async getUser(identifier) {
    var _a;
    if (!identifier && !this.authenticated)
      throw new Error(
        "Not authenticated: You need to login or provide an indentifier"
      );
    let email = null;
    if (identifier && isEmail(identifier)) {
      email = identifier;
      identifier = await this.resolveCachedKaid(identifier);
    }
    const response = await getFullUserProfile(
      identifier,
      !identifier ? { credentials: "include", headers: { cookie: __privateGet(this, _cookies) } } : void 0
    );
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.user)
      throw new Error("User not found");
    const user = User.fromSchema(json.data.user);
    user.client = this;
    if (!user.email && email && isEmail(email))
      user.copy({ email });
    if (user.self)
      this.user = user;
    if (user.kaid) {
      if (user.username && !__privateGet(this, _cachedKaids).has(user.username))
        __privateGet(this, _cachedKaids).set(user.username, user.kaid);
      if (user.email && !__privateGet(this, _cachedKaids).has(user.email))
        __privateGet(this, _cachedKaids).set(user.email, user.kaid);
    }
    return user;
  }
  // @TODO Should probably be renamed to `getUserAvatar`
  async getAvatar(identifier = this.kaid ?? __privateGet(this, _identifier), type = "svg") {
    var _a;
    if (!identifier)
      throw new Error("No identifier provided");
    if (!isKaid(identifier))
      identifier = await this.resolveCachedKaid(identifier);
    const response = await avatarDataForProfile(identifier);
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.user)
      throw new Error("User not found");
    const slug = extractAvatarSlug(json.data.user.avatar.imageSrc);
    if (!slug)
      throw new Error("User has no avatar");
    return type === "svg" ? generateAvatarSVG(slug) : generateAvatarPNG(slug);
  }
  async getUserStatistics(identifier = this.kaid ?? __privateGet(this, _identifier)) {
    var _a;
    if (!identifier)
      throw new Error("No identifier provided");
    if (!isKaid(identifier))
      identifier = await this.resolveCachedKaid(identifier);
    const response = await getProfileWidgets(identifier);
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.user)
      throw new Error("User not found");
    return {
      votes: json.data.userSummary.statistics.votes,
      tipsAndThanks: json.data.userSummary.statistics.comments,
      questions: json.data.userSummary.statistics.questions,
      answers: json.data.userSummary.statistics.answers,
      helpRequests: json.data.userSummary.statistics.projectquestions,
      helpRequestAnswers: json.data.userSummary.statistics.projectanswers,
      replies: json.data.userSummary.statistics.replies,
      flags: json.data.userSummary.statistics.flags
    };
  }
  async *getUserPrograms(identifier, sort = "TOP" /* TOP */, limit = 40) {
    if (!identifier && !this.authenticated)
      throw new Error(
        "Not authenticated: You need to login or provide an indentifier"
      );
    identifier ??= this.kaid ?? this.user?.username ?? this.user?.email;
    if (!identifier)
      throw new Error("Missing identifier for logged in user");
    const kaid = await this.resolveCachedKaid(identifier);
    const variables = {
      kaid,
      pageInfo: {
        cursor: null,
        itemsPerPage: limit
      },
      sort
    };
    const getUserProgramsPage = async (cursor2) => {
      var _a;
      const reponse = await projectsAuthoredByUser({
        ...variables,
        pageInfo: {
          ...variables.pageInfo,
          cursor: cursor2
        }
      });
      const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, reponse);
      assertDataResponse(json);
      if (!json.data.user)
        throw new Error("User not found");
      if (!json.data.user.programs.complete && !json.data.user.programs.cursor)
        throw new Error("Cursor not found");
      const programSchemas = json.data.user.programs.programs;
      const programs2 = programSchemas.map((programSchema) => {
        const program = Program.fromSchema(programSchema);
        program.client = this;
        return program;
      });
      const nextCursor = !json.data.user.programs.complete && json.data.user.programs.cursor;
      return { programs: programs2, cursor: nextCursor };
    };
    let { programs, cursor } = await getUserProgramsPage();
    yield programs;
    while (cursor) {
      ;
      ({ programs, cursor } = await getUserProgramsPage(cursor));
      yield programs;
    }
  }
  async getAllUserPrograms(identifier, sort = "TOP" /* TOP */, limit = 100) {
    const programs = [];
    for await (const page of this.getUserPrograms(identifier, sort, limit)) {
      programs.push(...page);
    }
    return programs;
  }
  /**
   * @param identifier Program ID, URL or key
   */
  async getProgram(identifier) {
    var _a;
    identifier = resolveProgramID(identifier);
    const response = await programQuery(identifier);
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.programById)
      throw new Error("Program not found");
    const program = Program.fromSchema(json.data.programById);
    program.client = this;
    if (this.user && program.author?.kaid === this.kaid) {
      program.copy({
        author: this.user
      });
      console.debug(
        `Copied the client's user data to program ${program.title ? `"${truncate(program.title, 32)}"` : program.id ?? "unknown"} because the program's author matches the client user`
      );
    }
    return program;
  }
  /**
   * Gets a single message by its feedback key or encrypted feedback key
   *
   * @remarks
   * This method is not recommended when you know the message's type. Use
   * {@link Client!Client.getTipsAndThanks | `getTipsAndThanks`},
   * {@link Client!Client.getQuestion | `getQuestion`} or
   * {@link Client!Client.getReply | `getReply`} instead.
   *
   * @param identifier Feedback key or encrypted feedback key
   */
  async getMessage(identifier) {
    var _a;
    if (!isFeedbackKey(identifier))
      identifier = await this.resolveCachedFeedbackKey(identifier);
    const response = await feedbackQuery({
      topicId: PLACEHOLDER_PROGRAM_ID.toString(),
      focusKind: "Scratchpad" /* Scratchpad */,
      feedbackType: "COMMENT" /* COMMENT */,
      currentSort: 1 /* TopVoted */,
      qaExpandKey: identifier
    });
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.feedback || !json.data.feedback.feedback || json.data.feedback.feedback.length === 0)
      throw new Error("Message not found");
    const messageSchema = json.data.feedback.feedback[0];
    let message;
    if (isTipsAndThanksSchema(messageSchema))
      message = TipsAndThanks.fromSchema(messageSchema);
    else if (isQuestionSchema(messageSchema)) {
      const question = Question.fromSchema(messageSchema);
      if (question.key !== identifier) {
        const answer = question.answers?.find(
          (answer2) => answer2.key === identifier
        );
        if (!answer)
          throw new Error("Question or answer not found");
        message = answer;
        message.copy({ question });
      } else
        message = question;
    } else
      throw new Error("Unknown message type");
    message.client = this;
    if (this.user && message.author?.kaid === this.kaid) {
      message.copy({
        author: this.user
      });
      console.debug(
        `Copied the client's user data to comment ${message.key ?? message.encryptedKey ?? "unknown"} because the comment's author matches the client user`
      );
    }
    return message;
  }
  /**
   * Gets a single tips and thanks message
   *
   * @param identifier Feedback key or encrypted feedback key
   */
  async getTipsAndThanks(identifier) {
    return this.getMessage(identifier);
  }
  /**
   * Gets a single question message
   *
   * @remarks
   * Note that Help Requests are a type of question.
   *
   * @param identifier Feedback key or encrypted feedback key
   */
  async getQuestion(identifier) {
    return this.getMessage(identifier);
  }
  /**
   * Gets a single answer message
   *
   * @param identifier Feedback key or encrypted feedback key
   */
  async getAnswer(identifier) {
    return this.getMessage(identifier);
  }
  /**
   * Gets a single reply
   *
   * @param identifier Feedback key or encrypted feedback key
   */
  async getReply(identifier) {
    var _a;
    const message = await this.getMessage(identifier);
    if (!message.key)
      throw new Error("Message has no key");
    const response = await getFeedbackReplies(message.key);
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.feedbackReplies || json.data.feedbackReplies.length === 0)
      throw new Error("Reply not found");
    const replySchema = json.data.feedbackReplies.find(
      (reply2) => reply2.expandKey === identifier || reply2.key === identifier
    );
    if (!replySchema)
      throw new Error("Reply not found");
    const reply = Reply.fromSchema(replySchema);
    reply.client = this;
    reply.copy({
      message
    });
    if (this.user && reply.author?.kaid === this.kaid) {
      reply.copy({
        author: this.user
      });
      console.debug(
        `Copied the client's user data to reply ${reply.key ?? reply.encryptedKey ?? "unknown"} because the reply's author matches the client user`
      );
    }
    return reply;
  }
  /**
   * Gets specified types of messages for a program
   *
   * @param identifier Program ID, program URL, or program key
   *
   * @example
   * const client = new Client()
   * for await (const messages of client.getProgramTipsAndThanks(5154160781082624)) {
   *   console.log(messages.map(message => message.text)
   * }
   */
  async *getProgramMessages(type = Message.Type.TipsAndThanks, identifier, sort = 1 /* TopVoted */) {
    identifier = resolveProgramID(identifier);
    const variables = {
      topicId: identifier.toString(),
      focusKind: "Scratchpad" /* Scratchpad */,
      feedbackType: type,
      currentSort: sort
    };
    const getProgramMessagesPage = async (cursor2) => {
      var _a;
      const response = await feedbackQuery({
        ...variables,
        cursor: cursor2
      });
      const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
      assertDataResponse(json);
      if (!json.data.feedback.feedback)
        throw new Error("Comments not found");
      if (!json.data.feedback.isComplete && !json.data.feedback.cursor)
        throw new Error("Cursor not found");
      const feedback = json.data.feedback.feedback;
      const messages2 = feedback.map((feedback2) => {
        const message = TypeToClass[type].fromSchema(feedback2);
        message.client = this;
        return message;
      });
      const nextCursor = !json.data.feedback.isComplete && json.data.feedback.cursor;
      return {
        messages: messages2,
        cursor: nextCursor
      };
    };
    let { messages, cursor } = await getProgramMessagesPage();
    yield messages;
    while (cursor) {
      ;
      ({ messages, cursor } = await getProgramMessagesPage(cursor));
      yield messages;
    }
  }
  /**
   * Gets all specified types of messages for a program
   *
   * @see {@link Client!Client.getProgramMessages}
   *
   * @example
   * const client = new Client()
   * const messages = await client.getAllProgramMessages(undefined, 5154160781082624)
   * console.log(messages.map(message => message.text)
   */
  async getAllProgramMessages(type = Message.Type.TipsAndThanks, identifier, sort = 1 /* TopVoted */) {
    const messages = [];
    for await (const page of this.getProgramMessages(type, identifier, sort)) {
      messages.push(...page);
    }
    return messages;
  }
  /**
   * Gets Tips and Thanks messages for a program
   *
   * @see {@link Client!Client.getProgramMessages}
   */
  async *getProgramTipsAndThanks(identifier, sort = 1 /* TopVoted */) {
    yield* this.getProgramMessages(
      Message.Type.TipsAndThanks,
      identifier,
      sort
    );
  }
  /**
   * Gets all Tips and Thanks messages for a program
   *
   * @see {@link Client!Client.getAllProgramMessages}
   */
  async getAllProgramTipsAndThanks(identifier, sort = 1 /* TopVoted */) {
    return this.getAllProgramMessages(
      Message.Type.TipsAndThanks,
      identifier,
      sort
    );
  }
  /**
   * Gets questions for a program
   *
   * @see {@link Client!Client.getProgramMessages}
   */
  async *getProgramQuestions(identifier, sort = 1 /* TopVoted */) {
    yield* this.getProgramMessages(
      Message.Type.Question,
      identifier,
      sort
    );
  }
  /**
   * Gets all questions for a program
   *
   * @see {@link Client!Client.getAllProgramMessages}
   */
  async getAllProgramQuestions(identifier, sort = 1 /* TopVoted */) {
    return this.getAllProgramMessages(
      Message.Type.Question,
      identifier,
      sort
    );
  }
  /**
   * Gets Help Requests for a program
   *
   * @see {@link Client!Client.getProgramMessages}
   */
  async *getProgramHelpRequests(identifier, sort = 1 /* TopVoted */) {
    yield* this.getProgramMessages(
      Message.Type.HelpRequest,
      identifier,
      sort
    );
  }
  /**
   * Gets all Help Requests for a program
   *
   * @see {@link Client!Client.getAllProgramMessages}
   */
  async getAllProgramHelpRequests(identifier, sort = 1 /* TopVoted */) {
    return this.getAllProgramMessages(
      Message.Type.HelpRequest,
      identifier,
      sort
    );
  }
  /**
   * Gets all replies to a message
   *
   * @rawEquivalent {@link queries!getFeedbackReplies}
   */
  async getAllMessageReplies(identifier) {
    var _a;
    identifier = await this.resolveCachedFeedbackKey(identifier);
    const response = await getFeedbackReplies(identifier);
    const json = await __privateMethod(_a = _Client, _resolveJsonReponse, resolveJsonReponse_fn).call(_a, response);
    assertDataResponse(json);
    if (!json.data.feedbackReplies)
      throw new Error("Replies not found");
    const replies = json.data.feedbackReplies.map((replySchema) => {
      const reply = Reply.fromSchema(replySchema);
      reply.client = this;
      return reply;
    });
    return replies;
  }
};
var Client = _Client;
_identifier = new WeakMap();
_password = new WeakMap();
_cookies = new WeakMap();
_cachedKaids = new WeakMap();
_cachedUsernames = new WeakMap();
_cachedFeedbackKeys = new WeakMap();
_resolveJsonReponse = new WeakSet();
resolveJsonReponse_fn = async function(response) {
  try {
    return await response.json();
  } catch (err) {
    const message = err instanceof Error ? err.message : typeof err === "string" ? err : "Unknown error";
    throw new Error(`Failed to parse response JSON: ${message}`);
  }
};
__privateAdd(Client, _resolveJsonReponse);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Answer,
  BaseMessage,
  Client,
  EmailRegex,
  EmailRegexMatch,
  FeedbackFocusKind,
  FeedbackKeyRegex,
  FeedbackKeyRegexMatch,
  FeedbackSort,
  FeedbackType,
  FeedbackTypename,
  GoogleIDRegex,
  GoogleIDRegexMatch,
  KaidRegex,
  KaidRegexMatch,
  ListProgramSortOrder,
  MESSAGE_ENCRYPTED_KEY_LENGTHS,
  MESSAGE_KEY_LENGTHS,
  Message,
  MessageEncryptedKeyRegex,
  MessageEncryptedKeyRegexMatch,
  MessageType,
  PROGRAM_ID_LENGTHS,
  PROGRAM_KEY_LENGTHS,
  PROGRAM_URL_LOCALES,
  PROGRAM_URL_PATHS,
  PROGRAM_URL_TLDS,
  Program,
  ProgramEditorType,
  ProgramIDRegex,
  ProgramIDRegexMatch,
  ProgramImagePathRegex,
  ProgramImagePathRegexMatch,
  ProgramKeyRegex,
  ProgramKeyRegexMatch,
  ProgramType,
  ProgramURLRegex,
  ProgramURLRegexMatch,
  QualarooIDRegex,
  QualarooIDRegexMatch,
  Question,
  Reply,
  ServiceErrorCode,
  ServiceErrorName,
  TipsAndThanks,
  TypeToClass,
  User,
  UserAccessLevel,
  assertDataResponse,
  avatarNameToSlug,
  avatarNames,
  avatarSlugToName,
  avatarSlugs,
  convertAvatarPNGToSVG,
  convertAvatarSVGToPNG,
  extractAvatarSlug,
  generateAvatarPNG,
  generateAvatarSVG,
  isAnswerSchema,
  isDataResponse,
  isEmail,
  isEncryptedFeedbackKey,
  isFeedbackKey,
  isGoogleID,
  isInputErrorResponse,
  isKaid,
  isProgramID,
  isProgramKey,
  isProgramURL,
  isQualarooID,
  isQuestionSchema,
  isReplySchema,
  isServiceErrorsResponse,
  isTipsAndThanksSchema,
  mutations,
  programIDtoKey,
  programKeyToID,
  queries,
  resolveFeedbackKey,
  resolveKaid,
  resolveProgramID,
  resolveUsername
});
//# sourceMappingURL=khan-api.cjs.map
